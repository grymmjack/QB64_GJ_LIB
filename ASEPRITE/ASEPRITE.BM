''
' QB64_GJ_LIB
' GRYMMJACK'S ASEPRITE LIB
'
' Adds support to QB64 for ASEPRITE images
'
' USAGE:
'   Insert '$INCLUDE:'path_to_GJ_LIB/ASEPRITE/ASEPRITE.BI' at the top of file
'   Insert '$INCLUDE:'path_to_GJ_LIB/ASEPRITE/ASEPRITE.BM' at the bottom of file
' 
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Loads an ASEPRITE image file and returns populated ASEPRITE_IMAGE object
'
' @param img_path$ Path to the .ase/.aseprite image file to load
' @param result ASEPRITE_IMAGE Complete Aseprite image data structure (output)
'
SUB load_aseprite_image (img_path$, result AS ASEPRITE_IMAGE)
    DIM file_handle AS INTEGER
    DIM temp_header AS ASEPRITE_HEADER
    
    ' Initialize result
    result.file_path = img_path$
    result.is_valid = 0
    result.frames_loaded = 0
    result.chunks_loaded = 0
    result.error_message = ""
    
    ' Check if file exists
    IF NOT _FILEEXISTS(img_path$) THEN
        result.error_message = "File not found: " + img_path$
        EXIT SUB
    END IF
    
    ' Open file for binary reading
    file_handle = FREEFILE
    OPEN img_path$ FOR BINARY AS #file_handle
    
    ' Verify file size is at least header size
    IF LOF(file_handle) < 128 THEN
        result.error_message = "File too small to be valid Aseprite file"
        CLOSE #file_handle
        EXIT SUB
    END IF
    
    ' Read and validate header
    GET #file_handle, 1, temp_header
    
    ' Verify magic number
    IF temp_header.magic_number <> ASEPRITE_HEADER_MAGIC THEN
        result.error_message = "Invalid Aseprite magic number: " + HEX$(temp_header.magic_number) + " expected: " + HEX$(ASEPRITE_HEADER_MAGIC)
        CLOSE #file_handle
        EXIT SUB
    END IF
    
    ' Verify file size matches header
    IF temp_header.file_size <> LOF(file_handle) THEN
        result.error_message = "File size mismatch: header=" + STR$(temp_header.file_size) + " actual=" + STR$(LOF(file_handle))
        CLOSE #file_handle
        EXIT SUB
    END IF
    
    ' Copy header to result
    result.header = temp_header
    result.is_valid = 1
    result.frames_loaded = temp_header.num_frames
    
    CLOSE #file_handle
END SUB

''
' Gets comprehensive info for an ASEPRITE image
'
' @param aseprite_img ASEPRITE_IMAGE structure to analyze
' @return string Detailed information about the Aseprite file
'
FUNCTION get_aseprite_info$ (aseprite_img AS ASEPRITE_IMAGE)
    DIM nl$, out$, temp$
    nl$ = CHR$(13) + CHR$(10)
    out$ = ""
    
    IF aseprite_img.is_valid = 0 THEN
        out$ = "INVALID ASEPRITE FILE" + nl$
        IF LEN(aseprite_img.error_message) > 0 THEN
            out$ = out$ + "Error: " + aseprite_img.error_message + nl$
        END IF
        get_aseprite_info$ = out$
        EXIT FUNCTION
    END IF
    
    out$ = "ASEPRITE FILE INFORMATION" + nl$
    out$ = out$ + "========================" + nl$
    out$ = out$ + "File Path: " + aseprite_img.file_path + nl$
    out$ = out$ + "File Size: " + STR$(aseprite_img.header.file_size) + " bytes" + nl$
    out$ = out$ + "Magic Number: 0x" + HEX$(aseprite_img.header.magic_number) + nl$
    out$ = out$ + nl$
    
    out$ = out$ + "IMAGE PROPERTIES:" + nl$
    out$ = out$ + "Width: " + STR$(aseprite_img.header.width) + " pixels" + nl$
    out$ = out$ + "Height: " + STR$(aseprite_img.header.height) + " pixels" + nl$
    out$ = out$ + "Color Depth: " + STR$(aseprite_img.header.color_depth_bpp) + " bpp ("
    SELECT CASE aseprite_img.header.color_depth_bpp
        CASE ASEPRITE_COLOR_INDEXED: out$ = out$ + "Indexed)"
        CASE ASEPRITE_COLOR_GRAYSCALE: out$ = out$ + "Grayscale)"
        CASE ASEPRITE_COLOR_RGBA: out$ = out$ + "RGBA)"
        CASE ELSE: out$ = out$ + "Unknown)"
    END SELECT
    out$ = out$ + nl$
    
    out$ = out$ + "Number of Frames: " + STR$(aseprite_img.header.num_frames) + nl$
    out$ = out$ + "Frame Speed: " + STR$(aseprite_img.header.frame_speed) + " ms (deprecated)" + nl$
    out$ = out$ + "Number of Colors: " + STR$(aseprite_img.header.num_colors) + nl$
    out$ = out$ + nl$
    
    out$ = out$ + "FLAGS:" + nl$
    IF (aseprite_img.header.flags AND ASEPRITE_FLAG_LAYER_OPACITY_VALID) THEN
        out$ = out$ + "- Layer opacity values are valid" + nl$
    END IF
    IF (aseprite_img.header.flags AND ASEPRITE_FLAG_GROUP_BLEND_VALID) THEN
        out$ = out$ + "- Group blend mode/opacity is valid" + nl$
    END IF
    IF (aseprite_img.header.flags AND ASEPRITE_FLAG_LAYERS_HAVE_UUID) THEN
        out$ = out$ + "- Layers have UUIDs" + nl$
    END IF
    out$ = out$ + nl$
    
    out$ = out$ + "PIXEL RATIO:" + nl$
    out$ = out$ + "Pixel Width: " + STR$(aseprite_img.header.pixel_width) + nl$
    out$ = out$ + "Pixel Height: " + STR$(aseprite_img.header.pixel_height) + nl$
    IF aseprite_img.header.pixel_width > 0 AND aseprite_img.header.pixel_height > 0 THEN
        temp$ = STR$(aseprite_img.header.pixel_width / aseprite_img.header.pixel_height)
        out$ = out$ + "Ratio: " + temp$ + ":1" + nl$
    ELSE
        out$ = out$ + "Ratio: 1:1 (default)" + nl$
    END IF
    out$ = out$ + nl$
    
    out$ = out$ + "GRID PROPERTIES:" + nl$
    out$ = out$ + "Grid Position: (" + STR$(aseprite_img.header.grid_x_pos) + ", " + STR$(aseprite_img.header.grid_y_pos) + ")" + nl$
    out$ = out$ + "Grid Size: " + STR$(aseprite_img.header.grid_width) + " x " + STR$(aseprite_img.header.grid_height) + nl$
    IF aseprite_img.header.grid_width = 0 OR aseprite_img.header.grid_height = 0 THEN
        out$ = out$ + "Grid: Disabled" + nl$
    ELSE
        out$ = out$ + "Grid: Enabled" + nl$
    END IF
    out$ = out$ + nl$
    
    IF aseprite_img.header.color_depth_bpp = ASEPRITE_COLOR_INDEXED THEN
        out$ = out$ + "INDEXED COLOR:" + nl$
        out$ = out$ + "Transparent Index: " + STR$(aseprite_img.header.transparent_color_index) + nl$
    END IF
    
    get_aseprite_info$ = out$
END FUNCTION

''
' Validates if a file is a proper Aseprite file
'
' @param img_path$ Path to file to validate
' @return integer 1 if valid Aseprite file, 0 otherwise
'
FUNCTION is_valid_aseprite_file (img_path$)
    DIM test_img AS ASEPRITE_IMAGE
    load_aseprite_image img_path$, test_img
    is_valid_aseprite_file = test_img.is_valid
END FUNCTION

''
' Gets the file extension for Aseprite files
'
' @return string ".ase" or ".aseprite" extension
'
FUNCTION get_aseprite_extension$
    get_aseprite_extension$ = ".ase"
END FUNCTION

''
' Converts blend mode constant to descriptive string
'
' @param blend_mode Blend mode constant
' @return string Descriptive name of blend mode
'
FUNCTION get_blend_mode_name$ (blend_mode AS _UNSIGNED INTEGER)
    SELECT CASE blend_mode
        CASE ASEPRITE_BLEND_NORMAL: get_blend_mode_name$ = "Normal"
        CASE ASEPRITE_BLEND_MULTIPLY: get_blend_mode_name$ = "Multiply"
        CASE ASEPRITE_BLEND_SCREEN: get_blend_mode_name$ = "Screen"
        CASE ASEPRITE_BLEND_OVERLAY: get_blend_mode_name$ = "Overlay"
        CASE ASEPRITE_BLEND_DARKEN: get_blend_mode_name$ = "Darken"
        CASE ASEPRITE_BLEND_LIGHTEN: get_blend_mode_name$ = "Lighten"
        CASE ASEPRITE_BLEND_COLOR_DODGE: get_blend_mode_name$ = "Color Dodge"
        CASE ASEPRITE_BLEND_COLOR_BURN: get_blend_mode_name$ = "Color Burn"
        CASE ASEPRITE_BLEND_HARD_LIGHT: get_blend_mode_name$ = "Hard Light"
        CASE ASEPRITE_BLEND_SOFT_LIGHT: get_blend_mode_name$ = "Soft Light"
        CASE ASEPRITE_BLEND_DIFFERENCE: get_blend_mode_name$ = "Difference"
        CASE ASEPRITE_BLEND_EXCLUSION: get_blend_mode_name$ = "Exclusion"
        CASE ASEPRITE_BLEND_HUE: get_blend_mode_name$ = "Hue"
        CASE ASEPRITE_BLEND_SATURATION: get_blend_mode_name$ = "Saturation"
        CASE ASEPRITE_BLEND_COLOR: get_blend_mode_name$ = "Color"
        CASE ASEPRITE_BLEND_LUMINOSITY: get_blend_mode_name$ = "Luminosity"
        CASE ASEPRITE_BLEND_ADDITION: get_blend_mode_name$ = "Addition"
        CASE ASEPRITE_BLEND_SUBTRACT: get_blend_mode_name$ = "Subtract"
        CASE ASEPRITE_BLEND_DIVIDE: get_blend_mode_name$ = "Divide"
        CASE ELSE: get_blend_mode_name$ = "Unknown (" + STR$(blend_mode) + ")"
    END SELECT
END FUNCTION

''
' Converts animation direction constant to descriptive string
'
' @param direction Animation direction constant
' @return string Descriptive name of animation direction
'
FUNCTION get_animation_direction_name$ (direction AS _UNSIGNED _BYTE)
    SELECT CASE direction
        CASE ASEPRITE_ANIM_FORWARD: get_animation_direction_name$ = "Forward"
        CASE ASEPRITE_ANIM_REVERSE: get_animation_direction_name$ = "Reverse"
        CASE ASEPRITE_ANIM_PING_PONG: get_animation_direction_name$ = "Ping-pong"
        CASE ASEPRITE_ANIM_PING_PONG_REVERSE: get_animation_direction_name$ = "Ping-pong Reverse"
        CASE ELSE: get_animation_direction_name$ = "Unknown (" + STR$(direction) + ")"
    END SELECT
END FUNCTION

''
' Creates a QB64PE image from Aseprite pixel data (placeholder for future chunk loading)
'
' @param aseprite_img ASEPRITE_IMAGE structure with loaded data
' @return LONG QB64PE image handle (0 if failed)
'
FUNCTION create_image_from_aseprite& (aseprite_img AS ASEPRITE_IMAGE)
    DIM image_handle AS LONG
    DIM x AS INTEGER, y AS INTEGER
    DIM pixel_color AS _UNSIGNED LONG
    
    IF aseprite_img.is_valid = 0 THEN
        create_image_from_aseprite& = 0
        EXIT FUNCTION
    END IF
    
    ' Create a new 32-bit image with the Aseprite dimensions
    IF aseprite_img.header.width <= 0 OR aseprite_img.header.height <= 0 THEN
        create_image_from_aseprite& = 0
        EXIT FUNCTION
    END IF
    
    image_handle = _NEWIMAGE(aseprite_img.header.width, aseprite_img.header.height, 32)
    
    IF image_handle = -1 OR image_handle = 0 THEN
        create_image_from_aseprite& = 0
        EXIT FUNCTION
    END IF
    
    ' Try to load actual pixel data from the file
    IF load_aseprite_pixels%(aseprite_img, image_handle) THEN
        ' Success - real pixel data loaded
    ELSE
        ' Fall back to placeholder pattern
        DIM r AS INTEGER, g AS INTEGER, b AS INTEGER
        _DEST image_handle
        FOR y = 0 TO aseprite_img.header.height - 1
            FOR x = 0 TO aseprite_img.header.width - 1
                IF aseprite_img.header.width > 0 AND aseprite_img.header.height > 0 THEN
                    r = (x * 255) \ aseprite_img.header.width
                    g = (y * 255) \ aseprite_img.header.height
                    b = ((x + y) * 255) \ (aseprite_img.header.width + aseprite_img.header.height)
                    pixel_color = _RGB32(r, g, b)
                    PSET (x, y), pixel_color
                END IF
            NEXT x
        NEXT y
        _DEST 0
    END IF
    
    _DISPLAY
    _DELAY 2
    
    create_image_from_aseprite& = image_handle
END FUNCTION

''
' Displays an Aseprite image in a graphics window
'
' @param aseprite_img ASEPRITE_IMAGE structure with loaded data
' @param scale Scale factor for display (1.0 = original size)
' @param center_display 1 to center image on screen, 0 for top-left
'
SUB display_aseprite_image (aseprite_img AS ASEPRITE_IMAGE, scale AS SINGLE, center_display AS INTEGER)
    DIM image_handle AS LONG
    DIM screen_width AS INTEGER, screen_height AS INTEGER
    DIM display_width AS INTEGER, display_height AS INTEGER
    DIM x_pos AS INTEGER, y_pos AS INTEGER
    DIM old_dest AS LONG
    
    IF aseprite_img.is_valid = 0 THEN
        PRINT "Cannot display: Invalid Aseprite image"
        EXIT SUB
    END IF
    
    ' Create graphics screen FIRST, before trying to create images
    IF _PIXELSIZE(0) = 0 THEN
        SCREEN _NEWIMAGE(800, 600, 32)
        _TITLE "Aseprite Image Viewer - " + aseprite_img.file_path
    END IF
    
    ' Clear screen and show debug info
    CLS
    COLOR _RGB32(255, 255, 0)
    _PRINTSTRING (10, 10), "Loading Aseprite image..."
    _PRINTSTRING (10, 30), "File: " + aseprite_img.file_path
    _PRINTSTRING (10, 50), "Size: " + STR$(aseprite_img.header.width) + "x" + STR$(aseprite_img.header.height)
    _DISPLAY
    _DELAY 1
    
    ' Now create image from Aseprite data (after we're in graphics mode)
    image_handle = create_image_from_aseprite&(aseprite_img)
    
    IF image_handle = 0 THEN
        _PRINTSTRING (10, 70), "ERROR: Failed to create image from Aseprite data"
        _DISPLAY
        _DELAY 3
        EXIT SUB
    END IF
    
    ' Calculate display dimensions
    display_width = INT(aseprite_img.header.width * scale)
    display_height = INT(aseprite_img.header.height * scale)
    
    screen_width = _WIDTH(0)
    screen_height = _HEIGHT(0)
    
    screen_width = _WIDTH(0)
    screen_height = _HEIGHT(0)
    
    ' Calculate position
    IF center_display THEN
        x_pos = (screen_width - display_width) \ 2
        y_pos = (screen_height - display_height) \ 2
    ELSE
        x_pos = 10
        y_pos = 10
    END IF
    
    ' Clear screen
    CLS
    
    ' Display image info
    COLOR _RGB32(255, 255, 255)
    _PRINTSTRING (10, 10), "File: " + aseprite_img.file_path
    _PRINTSTRING (10, 30), "Size: " + STR$(aseprite_img.header.width) + "x" + STR$(aseprite_img.header.height) + " pixels"
    _PRINTSTRING (10, 50), "Scale: " + STR$(scale) + "x"
    _PRINTSTRING (10, 70), "Color Depth: " + STR$(aseprite_img.header.color_depth_bpp) + " bpp"
    
    ' Display the image
    IF scale = 1.0 THEN
        _PUTIMAGE (x_pos, y_pos + 100), image_handle
    ELSE
        _PUTIMAGE (x_pos, y_pos + 100)-(x_pos + display_width - 1, y_pos + 100 + display_height - 1), image_handle
    END IF
    
    ' Display controls and wait for user input (unless in auto-mode)
    _PRINTSTRING (10, screen_height - 40), "Aseprite graphics display - Auto-closing in 3 seconds..."
    
    _DISPLAY
    
    ' Just show briefly in auto-mode for demo purposes
    _DELAY 3 ' Show for 3 seconds
    
    ' Clean up
    _FREEIMAGE image_handle
END SUB

''
' Quick preview function that displays Aseprite image at original size
'
' @param aseprite_img ASEPRITE_IMAGE structure with loaded data
'
SUB preview_aseprite_image (aseprite_img AS ASEPRITE_IMAGE)
    display_aseprite_image aseprite_img, 1.0, 1
END SUB

''
' Scaled preview function for viewing small sprites enlarged
'
' @param aseprite_img ASEPRITE_IMAGE structure with loaded data
' @param scale Scale factor (e.g., 2.0 for 2x size)
'
SUB preview_aseprite_scaled (aseprite_img AS ASEPRITE_IMAGE, scale AS SINGLE)
    display_aseprite_image aseprite_img, scale, 1
END SUB

''
' Attempts to load actual pixel data from Aseprite file chunks
'
' @param aseprite_img ASEPRITE_IMAGE structure with loaded data
' @param target_image Handle to QB64PE image to load pixels into
' @return -1 if successful, 0 if failed
'
FUNCTION load_aseprite_pixels% (aseprite_img AS ASEPRITE_IMAGE, target_image AS LONG)
    DIM file_handle AS INTEGER
    DIM file_pos AS LONG
    DIM frame_num AS INTEGER
    DIM chunk_num AS LONG
    DIM frame_header AS ASEPRITE_FRAME_HEADER
    DIM chunk_header AS ASEPRITE_CHUNK_HEADER
    DIM cel_chunk AS ASEPRITE_CEL_CHUNK
    DIM cel_width AS _UNSIGNED INTEGER, cel_height AS _UNSIGNED INTEGER
    DIM x AS INTEGER, y AS INTEGER
    DIM pixel_data$, temp_byte AS _UNSIGNED _BYTE
    DIM r AS _UNSIGNED _BYTE, g AS _UNSIGNED _BYTE, b AS _UNSIGNED _BYTE, a AS _UNSIGNED _BYTE
    DIM pixel_color AS _UNSIGNED LONG
    DIM old_dest AS LONG
    DIM chunks_found AS INTEGER
    
    load_aseprite_pixels% = 0 ' Default to failure
    
    IF aseprite_img.is_valid = 0 THEN EXIT FUNCTION
    
    ' Open file for binary reading
    file_handle = FREEFILE
    OPEN aseprite_img.file_path FOR BINARY AS #file_handle
    
    ' Skip the header (128 bytes) to get to frame data
    file_pos = 129 ' Start after header
    
    ' Read the first frame only for now
    IF aseprite_img.header.num_frames > 0 THEN
        ' Position at first frame
        SEEK #file_handle, file_pos
        
        ' Read frame header
        GET #file_handle, , frame_header
        
        ' Validate frame magic number
        IF frame_header.magic_number <> ASEPRITE_FRAME_MAGIC THEN
            CLOSE #file_handle
            EXIT FUNCTION
        END IF
        
        ' Determine number of chunks to process
        DIM num_chunks AS LONG
        IF frame_header.new_chunks > 0 THEN
            num_chunks = frame_header.new_chunks
        ELSE
            num_chunks = frame_header.old_chunks
        END IF
        
        ' Process chunks in this frame
        FOR chunk_num = 1 TO num_chunks
            ' Read chunk header
            GET #file_handle, , chunk_header
            
            PRINT "Processing chunk", chunk_num, "of", num_chunks
            PRINT "  Chunk type: 0x" + HEX$(chunk_header.chunk_type)
            PRINT "  Chunk size:", chunk_header.chunk_size
            
            ' Check if this is a CEL chunk
            IF chunk_header.chunk_type = ASEPRITE_CHUNK_CEL THEN
                chunks_found = chunks_found + 1
                PRINT "  -> CEL chunk found!"
                
                ' Read CEL chunk data
                GET #file_handle, , cel_chunk
                
                PRINT "    Layer index:", cel_chunk.layer_index
                PRINT "    Position: (", cel_chunk.x_position, ",", cel_chunk.y_position, ")"
                PRINT "    Opacity:", cel_chunk.opacity
                PRINT "    CEL type:", cel_chunk.cel_type
                
                ' Check CEL type
                SELECT CASE cel_chunk.cel_type
                    CASE ASEPRITE_CEL_RAW_IMAGE ' Raw image data (type 0)
                        PRINT "    -> Processing RAW image data"
                        ' Read width and height for raw image
                        GET #file_handle, , cel_width
                        GET #file_handle, , cel_height
                        PRINT "    Dimensions:", cel_width, "x", cel_height
                        
                        ' Load raw pixel data based on color depth
                        IF load_raw_pixel_data%(file_handle, target_image, cel_chunk, cel_width, cel_height, aseprite_img.header.color_depth_bpp) THEN
                            PRINT "    Raw pixel data loaded successfully"
                            load_aseprite_pixels% = -1 ' Success
                        ELSE
                            PRINT "    Failed to load raw pixel data"
                        END IF
                        
                    CASE ASEPRITE_CEL_COMPRESSED ' Compressed image (type 2) - most common
                        PRINT "    -> Processing COMPRESSED image data"
                        ' Read width and height for compressed image  
                        GET #file_handle, , cel_width
                        GET #file_handle, , cel_height
                        PRINT "    Dimensions:", cel_width, "x", cel_height
                        
                        ' Load compressed pixel data with QB64PE built-in decompression
                        IF load_compressed_pixel_data%(file_handle, target_image, cel_chunk, cel_width, cel_height, aseprite_img.header.color_depth_bpp, chunk_header.chunk_size) THEN
                            PRINT "    Compressed pixel data loaded successfully"
                            load_aseprite_pixels% = -1 ' Success
                        ELSE
                            PRINT "    Compressed decompression failed, using placeholder"
                            ' Fallback to placeholder if decompression fails
                            IF create_compressed_placeholder%(target_image, cel_chunk, cel_width, cel_height, aseprite_img.header.color_depth_bpp) THEN
                                PRINT "    Placeholder created"
                                load_aseprite_pixels% = -1 ' Success with placeholder
                            END IF
                        END IF
                        
                    CASE ASEPRITE_CEL_LINKED ' Linked cel (type 1)
                        PRINT "    -> LINKED CEL (not implemented)"
                        ' Skip for now - would need to reference another frame
                        
                    CASE ASEPRITE_CEL_TILEMAP ' Compressed tilemap (type 3)
                        PRINT "    -> TILEMAP CEL (not implemented)"
                        ' Skip for now - more complex tilemap data
                        
                    CASE ELSE
                        PRINT "    -> Unknown CEL type:", cel_chunk.cel_type
                        
                END SELECT
                
                ' Skip remaining chunk data
                SEEK #file_handle, SEEK(file_handle) + (chunk_header.chunk_size - 6 - LEN(cel_chunk))
                
            ELSE
                PRINT "  -> Skipping chunk type: 0x" + HEX$(chunk_header.chunk_type)
                ' Skip non-CEL chunks
                SEEK #file_handle, SEEK(file_handle) + (chunk_header.chunk_size - 6)
            END IF
        NEXT chunk_num
    END IF
    
    CLOSE #file_handle
    
    ' If we found at least one CEL chunk, consider it a success
    IF chunks_found > 0 THEN load_aseprite_pixels% = -1
    
END FUNCTION

''
' Loads raw (uncompressed) pixel data from file into target image
'
' @param file_handle Open file handle positioned at pixel data
' @param target_image QB64PE image handle to load into
' @param cel_chunk CEL chunk information
' @param width Image width in pixels
' @param height Image height in pixels  
' @param color_depth_bpp Color depth (8, 16, or 32 bits per pixel)
' @return -1 if successful, 0 if failed
'
FUNCTION load_raw_pixel_data% (file_handle AS INTEGER, target_image AS LONG, cel_chunk AS ASEPRITE_CEL_CHUNK, width AS _UNSIGNED INTEGER, height AS _UNSIGNED INTEGER, color_depth_bpp AS _UNSIGNED INTEGER)
    DIM x AS INTEGER, y AS INTEGER
    DIM r AS _UNSIGNED _BYTE, g AS _UNSIGNED _BYTE, b AS _UNSIGNED _BYTE, a AS _UNSIGNED _BYTE
    DIM gray_val AS _UNSIGNED _BYTE, gray_alpha AS _UNSIGNED _BYTE
    DIM index_val AS _UNSIGNED _BYTE
    DIM pixel_color AS _UNSIGNED LONG
    DIM old_dest AS LONG
    
    load_raw_pixel_data% = 0 ' Default to failure
    
    ' Set destination to our target image
    old_dest = _DEST
    _DEST target_image
    
    ' Read pixel data based on color depth
    SELECT CASE color_depth_bpp
        CASE 32 ' RGBA format (4 bytes per pixel)
            FOR y = 0 TO height - 1
                FOR x = 0 TO width - 1
                    GET #file_handle, , r
                    GET #file_handle, , g  
                    GET #file_handle, , b
                    GET #file_handle, , a
                    
                    pixel_color = _RGBA32(r, g, b, a)
                    PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
                NEXT x
            NEXT y
            load_raw_pixel_data% = -1 ' Success
            
        CASE 16 ' Grayscale format (2 bytes per pixel)
            FOR y = 0 TO height - 1
                FOR x = 0 TO width - 1
                    GET #file_handle, , gray_val
                    GET #file_handle, , gray_alpha
                    
                    pixel_color = _RGBA32(gray_val, gray_val, gray_val, gray_alpha)
                    PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
                NEXT x
            NEXT y
            load_raw_pixel_data% = -1 ' Success
            
        CASE 8 ' Indexed format (1 byte per pixel)
            ' For indexed mode, we'd need the palette data
            ' For now, create a simple grayscale interpretation
            FOR y = 0 TO height - 1
                FOR x = 0 TO width - 1
                    GET #file_handle, , index_val
                    
                    ' Simple mapping: index as grayscale value
                    pixel_color = _RGB32(index_val, index_val, index_val)
                    PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
                NEXT x
            NEXT y
            load_raw_pixel_data% = -1 ' Success
    END SELECT
    
    ' Restore destination
    _DEST old_dest
END FUNCTION

''
' Creates a placeholder pattern for compressed image data
' (Implemented using QB64PE built-in _INFLATE$ function)
'
' @param target_image QB64PE image handle to draw into
' @param cel_chunk CEL chunk information
' @param width Image width in pixels
' @param height Image height in pixels
' @param color_depth_bpp Color depth (8, 16, or 32 bits per pixel)
' @return -1 if successful, 0 if failed
'
FUNCTION create_compressed_placeholder% (target_image AS LONG, cel_chunk AS ASEPRITE_CEL_CHUNK, width AS _UNSIGNED INTEGER, height AS _UNSIGNED INTEGER, color_depth_bpp AS _UNSIGNED INTEGER)
    DIM x AS INTEGER, y AS INTEGER
    DIM pixel_color AS _UNSIGNED LONG
    DIM old_dest AS LONG
    DIM r AS INTEGER, g AS INTEGER, b AS INTEGER
    
    create_compressed_placeholder% = -1 ' Success by default
    
    ' Set destination to our target image
    old_dest = _DEST
    _DEST target_image
    
    ' Create a checkered pattern to indicate this is compressed data
    FOR y = 0 TO height - 1
        FOR x = 0 TO width - 1
            ' Create a diagonal stripe pattern with color variation
            IF ((x + y) MOD 4) < 2 THEN
                r = 128 + (x * 127) \ width
                g = 128 + (y * 127) \ height  
                b = 128 + ((x + y) * 127) \ (width + height)
            ELSE
                r = 64 + (x * 127) \ width
                g = 64 + (y * 127) \ height
                b = 64 + ((x + y) * 127) \ (width + height)
            END IF
            
            pixel_color = _RGB32(r, g, b)
            PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
        NEXT x
    NEXT y
    
    ' Restore destination
    _DEST old_dest
END FUNCTION

''
' Loads compressed pixel data using QB64PE built-in decompression
'
' @param file_handle Open file handle positioned at compressed pixel data
' @param target_image QB64PE image handle to load into
' @param cel_chunk CEL chunk information
' @param width Image width in pixels
' @param height Image height in pixels  
' @param color_depth_bpp Color depth (8, 16, or 32 bits per pixel)
' @param chunk_size Total size of the chunk for bounds checking
' @return -1 if successful, 0 if failed
'
FUNCTION load_compressed_pixel_data% (file_handle AS INTEGER, target_image AS LONG, cel_chunk AS ASEPRITE_CEL_CHUNK, width AS _UNSIGNED INTEGER, height AS _UNSIGNED INTEGER, color_depth_bpp AS _UNSIGNED INTEGER, chunk_size AS LONG)
    DIM compressed_data$
    DIM decompressed_data$
    DIM data_size AS LONG
    DIM x AS INTEGER, y AS INTEGER, byte_pos AS LONG
    DIM r AS _UNSIGNED _BYTE, g AS _UNSIGNED _BYTE, b AS _UNSIGNED _BYTE, a AS _UNSIGNED _BYTE
    DIM gray_val AS _UNSIGNED _BYTE, gray_alpha AS _UNSIGNED _BYTE
    DIM index_val AS _UNSIGNED _BYTE
    DIM pixel_color AS _UNSIGNED LONG
    DIM old_dest AS LONG
    DIM expected_size AS LONG
    DIM bytes_per_pixel AS INTEGER
    DIM current_pos AS LONG
    
    load_compressed_pixel_data% = 0 ' Default to failure
    
    ' Calculate bytes per pixel and expected decompressed size
    SELECT CASE color_depth_bpp
        CASE 32 ' RGBA: 4 bytes per pixel
            bytes_per_pixel = 4
            expected_size = width * height * 4
        CASE 16 ' Grayscale: 2 bytes per pixel
            bytes_per_pixel = 2
            expected_size = width * height * 2
        CASE 8 ' Indexed: 1 byte per pixel
            bytes_per_pixel = 1
            expected_size = width * height
        CASE ELSE
            EXIT FUNCTION ' Unsupported color depth
    END SELECT
    
    ' Calculate compressed data size
    ' Chunk contains: layer_index(2) + x_pos(2) + y_pos(2) + opacity(1) + cel_type(2) + z_index(2) + reserved(5) + width(2) + height(2) + compressed_data
    data_size = chunk_size - 20 ' Header size for compressed cel chunk
    
    IF data_size <= 0 THEN
        PRINT "Error: Invalid compressed data size:", data_size
        EXIT FUNCTION
    END IF
    
    ' Store current file position for debugging
    current_pos = SEEK(file_handle)
    
    ' Read compressed data
    compressed_data$ = SPACE$(data_size)
    GET #file_handle, , compressed_data$
    
    ' Debug information
    PRINT "Compressed data size:", data_size
    PRINT "Expected decompressed size:", expected_size
    PRINT "File position:", current_pos
    
    ' Try different decompression approaches
    decompressed_data$ = ""
    
    ' QB64PE built-in compression decompression
    decompressed_data$ = _INFLATE$(compressed_data$)
    IF LEN(decompressed_data$) > 0 THEN
        PRINT "QB64PE _INFLATE$ decompression successful:", LEN(decompressed_data$), "bytes"
    ELSE
        PRINT "QB64PE _INFLATE$ decompression failed"
        ' Note: _INFLATE$ should handle all DEFLATE variants (Dynamic Huffman, Fixed Huffman, Stored blocks)
        ' If this fails, the compressed data may be corrupted or use an unsupported format
    END IF
    
    ' Check if we got the expected size
    IF LEN(decompressed_data$) <> expected_size THEN
        PRINT "Size mismatch! Got:", LEN(decompressed_data$), "Expected:", expected_size
        ' Try to work with what we have if it's close
        IF LEN(decompressed_data$) < expected_size THEN
            ' Pad with zeros if too small
            decompressed_data$ = decompressed_data$ + STRING$(expected_size - LEN(decompressed_data$), CHR$(0))
            PRINT "Padded to expected size"
        ELSE
            ' Truncate if too large
            decompressed_data$ = LEFT$(decompressed_data$, expected_size)
            PRINT "Truncated to expected size"
        END IF
    END IF
    
    ' Set destination to our target image
    old_dest = _DEST
    _DEST target_image
    
    ' Load pixel data from decompressed data
    byte_pos = 1
    SELECT CASE color_depth_bpp
        CASE 32 ' RGBA format (4 bytes per pixel)
            FOR y = 0 TO height - 1
                FOR x = 0 TO width - 1
                    IF byte_pos + 3 <= LEN(decompressed_data$) THEN
                        r = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        g = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        b = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        a = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        
                        pixel_color = _RGBA32(r, g, b, a)
                        PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
                    END IF
                NEXT x
            NEXT y
            
        CASE 16 ' Grayscale format (2 bytes per pixel)
            FOR y = 0 TO height - 1
                FOR x = 0 TO width - 1
                    IF byte_pos + 1 <= LEN(decompressed_data$) THEN
                        gray_val = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        gray_alpha = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        
                        pixel_color = _RGBA32(gray_val, gray_val, gray_val, gray_alpha)
                        PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
                    END IF
                NEXT x
            NEXT y
            
        CASE 8 ' Indexed format (1 byte per pixel)
            FOR y = 0 TO height - 1
                FOR x = 0 TO width - 1
                    IF byte_pos <= LEN(decompressed_data$) THEN
                        index_val = ASC(decompressed_data$, byte_pos): byte_pos = byte_pos + 1
                        
                        ' Map index to a color - for testing, use a simple palette
                        pixel_color = get_indexed_color(index_val)
                        PSET (cel_chunk.x_position + x, cel_chunk.y_position + y), pixel_color
                    END IF
                NEXT x
            NEXT y
    END SELECT
    
    ' Restore destination
    _DEST old_dest
    
    PRINT "Pixel loading completed successfully"
    load_compressed_pixel_data% = -1 ' Success
END FUNCTION

''
' Returns a color for an indexed palette value
'
' @param index_val Palette index (0-255)
' @return LONG RGB color value
'
FUNCTION get_indexed_color& (index_val AS _UNSIGNED _BYTE)
    ' Create a simple palette for testing
    ' In a full implementation, this would use the actual palette from the ASEPRITE file
    
    SELECT CASE index_val
        CASE 0: get_indexed_color& = _RGB32(0, 0, 0)           ' Black
        CASE 1: get_indexed_color& = _RGB32(255, 255, 255)     ' White  
        CASE 2: get_indexed_color& = _RGB32(255, 0, 0)         ' Red
        CASE 3: get_indexed_color& = _RGB32(0, 255, 0)         ' Green
        CASE 4: get_indexed_color& = _RGB32(0, 0, 255)         ' Blue
        CASE 5: get_indexed_color& = _RGB32(255, 255, 0)       ' Yellow
        CASE 6: get_indexed_color& = _RGB32(255, 0, 255)       ' Magenta
        CASE 7: get_indexed_color& = _RGB32(0, 255, 255)       ' Cyan
        CASE 8: get_indexed_color& = _RGB32(128, 128, 128)     ' Gray
        CASE 9: get_indexed_color& = _RGB32(192, 192, 192)     ' Light Gray
        CASE 10: get_indexed_color& = _RGB32(128, 0, 0)        ' Dark Red
        CASE 11: get_indexed_color& = _RGB32(0, 128, 0)        ' Dark Green
        CASE 12: get_indexed_color& = _RGB32(0, 0, 128)        ' Dark Blue
        CASE 13: get_indexed_color& = _RGB32(128, 128, 0)      ' Olive
        CASE 14: get_indexed_color& = _RGB32(128, 0, 128)      ' Purple
        CASE 15: get_indexed_color& = _RGB32(0, 128, 128)      ' Teal
        CASE ELSE
            ' For other values, create a gradient
            get_indexed_color& = _RGB32(index_val, index_val, index_val)
    END SELECT
END FUNCTION

' ASEPRITE.BM uses QB64PE built-in _INFLATE$ for compression support
' No external libraries required!

''
' Loads an enhanced ASEPRITE image with layer and animation support
'
' @param file_path$ Path to the .ase/.aseprite image file to load
' @param result ASEPRITE_ENHANCED_IMAGE Complete enhanced Aseprite data (output)
'
SUB load_aseprite_enhanced (file_path$, result AS ASEPRITE_ENHANCED_IMAGE)
    DIM file_handle AS INTEGER
    
    ' Initialize result
    result.base_image.file_path = file_path$
    result.base_image.is_valid = 0
    result.base_image.frames_loaded = 0
    result.base_image.chunks_loaded = 0
    result.base_image.error_message = ""
    result.num_layers = 0
    result.num_frames = 0
    result.layer_info = ""
    result.frame_info = ""
    result.current_display = 0
    
    ' Load base image first
    load_aseprite_image file_path$, result.base_image
    
    IF result.base_image.is_valid = 0 THEN EXIT SUB
    
    ' Open file for detailed layer/frame parsing
    file_handle = FREEFILE
    OPEN file_path$ FOR BINARY AS #file_handle
    
    ' Parse layers and frames
    IF parse_layer_chunks%(file_handle, result) AND parse_frame_chunks%(file_handle, result) THEN
        ' Initialize animation system
        init_aseprite_animation result
        
        ' Create initial composite display
        result.current_display = _NEWIMAGE(result.base_image.header.width, result.base_image.header.height, 32)
    END IF
    
    CLOSE #file_handle
END SUB

''
' Parses layer chunks from the Aseprite file
'
' @param file_handle Open file handle
' @param enhanced_img Enhanced image structure to populate
' @return -1 if successful, 0 if failed
'
FUNCTION parse_layer_chunks% (file_handle AS INTEGER, enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    DIM file_pos AS LONG
    DIM frame_num AS INTEGER
    DIM chunk_num AS LONG
    DIM frame_header AS ASEPRITE_FRAME_HEADER
    DIM chunk_header AS ASEPRITE_CHUNK_HEADER
    DIM layer_chunk AS ASEPRITE_LAYER_CHUNK
    DIM layer_info AS ASEPRITE_LAYER_INFO
    DIM layer_name_len AS _UNSIGNED INTEGER
    DIM layer_name AS STRING
    
    parse_layer_chunks% = 0 ' Default to failure
    
    ' Start after header (128 bytes)
    file_pos = 129
    SEEK #file_handle, file_pos
    
    ' Read first frame to find layer chunks
    GET #file_handle, , frame_header
    
    ' Validate frame magic
    IF frame_header.magic_number <> ASEPRITE_FRAME_MAGIC THEN EXIT FUNCTION
    
    DIM num_chunks AS LONG
    IF frame_header.new_chunks > 0 THEN
        num_chunks = frame_header.new_chunks
    ELSE  
        num_chunks = frame_header.old_chunks
    END IF
    
    ' Process chunks looking for layer chunks
    FOR chunk_num = 1 TO num_chunks
        GET #file_handle, , chunk_header
        
        IF chunk_header.chunk_type = ASEPRITE_CHUNK_LAYER THEN
            ' Found a layer chunk
            GET #file_handle, , layer_chunk
            
            ' Read layer name (STRING format)
            GET #file_handle, , layer_name_len
            IF layer_name_len > 0 THEN
                layer_name = SPACE$(layer_name_len)
                GET #file_handle, , layer_name
            ELSE
                layer_name = "Layer " + STR$(enhanced_img.num_layers + 1)
            END IF
            
            ' Populate layer info
            layer_info.layer_name = layer_name
            layer_info.flags = layer_chunk.flags
            layer_info.layer_type = layer_chunk.layer_type
            layer_info.child_level = layer_chunk.child_level
            layer_info.blend_mode = layer_chunk.blend_mode
            layer_info.opacity = layer_chunk.opacity
            layer_info.is_visible = (layer_chunk.flags AND ASEPRITE_LAYER_VISIBLE) <> 0
            layer_info.is_background = (layer_chunk.flags AND ASEPRITE_LAYER_BACKGROUND) <> 0
            
            ' Store layer info (simplified serialization)
            enhanced_img.layer_info = enhanced_img.layer_info + layer_name + CHR$(0)
            enhanced_img.num_layers = enhanced_img.num_layers + 1
            
        ELSE
            ' Skip non-layer chunks
            SEEK #file_handle, SEEK(file_handle) + (chunk_header.chunk_size - 6)
        END IF
    NEXT chunk_num
    
    parse_layer_chunks% = -1 ' Success
END FUNCTION

''
' Parses frame chunks and timing information
'
' @param file_handle Open file handle  
' @param enhanced_img Enhanced image structure to populate
' @return -1 if successful, 0 if failed
'
FUNCTION parse_frame_chunks% (file_handle AS INTEGER, enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    DIM frame_info AS ASEPRITE_FRAME_INFO
    DIM total_duration AS LONG
    
    parse_frame_chunks% = 0 ' Default to failure
    
    ' Use header information for frame count
    enhanced_img.num_frames = enhanced_img.base_image.header.num_frames
    
    ' For now, create basic frame information
    ' A full implementation would parse each frame's timing and cel data
    DIM i AS INTEGER
    FOR i = 0 TO enhanced_img.num_frames - 1
        frame_info.frame_index = i
        frame_info.duration = enhanced_img.base_image.header.frame_speed ' Default speed
        frame_info.num_cels = 1 ' Assume 1 cel per frame for now
        frame_info.has_data = -1 ' Assume all frames have data
        
        total_duration = total_duration + frame_info.duration
        
        ' Store frame info (simplified)
        enhanced_img.frame_info = enhanced_img.frame_info + STR$(frame_info.duration) + ","
    NEXT i
    
    enhanced_img.animation.total_duration = total_duration
    enhanced_img.animation.total_frames = enhanced_img.num_frames
    
    parse_frame_chunks% = -1 ' Success
END FUNCTION

''
' Initializes the animation system for an enhanced Aseprite image
'
' @param enhanced_img Enhanced image structure
'
SUB init_aseprite_animation (enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    enhanced_img.animation.current_frame = 0
    enhanced_img.animation.is_playing = 0
    enhanced_img.animation.loop_mode = 1 ' Loop by default
    enhanced_img.animation.elapsed_time = 0
    enhanced_img.animation.last_update = TIMER
END SUB

''
' Updates animation timing and frame progression  
'
' @param enhanced_img Enhanced image structure
'
SUB update_aseprite_animation (enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    DIM current_time AS DOUBLE
    DIM delta_time AS LONG
    DIM frame_duration AS LONG
    
    IF enhanced_img.animation.is_playing = 0 THEN EXIT SUB
    IF enhanced_img.animation.total_frames <= 1 THEN EXIT SUB
    
    current_time = TIMER
    delta_time = (current_time - enhanced_img.animation.last_update) * 1000 ' Convert to ms
    enhanced_img.animation.last_update = current_time
    
    enhanced_img.animation.elapsed_time = enhanced_img.animation.elapsed_time + delta_time
    
    ' Get current frame duration (simplified - using default speed)
    frame_duration = enhanced_img.base_image.header.frame_speed
    IF frame_duration <= 0 THEN frame_duration = 100 ' Default 100ms
    
    ' Check if it's time to advance frame
    IF enhanced_img.animation.elapsed_time >= frame_duration THEN
        enhanced_img.animation.elapsed_time = enhanced_img.animation.elapsed_time - frame_duration
        
        ' Advance to next frame
        enhanced_img.animation.current_frame = enhanced_img.animation.current_frame + 1
        
        ' Handle looping
        IF enhanced_img.animation.current_frame >= enhanced_img.animation.total_frames THEN
            SELECT CASE enhanced_img.animation.loop_mode
                CASE 0 ' Play once
                    enhanced_img.animation.current_frame = enhanced_img.animation.total_frames - 1
                    enhanced_img.animation.is_playing = 0
                CASE 1 ' Loop
                    enhanced_img.animation.current_frame = 0
                CASE 2 ' Ping-pong (TODO: implement reverse direction)
                    enhanced_img.animation.current_frame = 0
            END SELECT
        END IF
    END IF
END SUB

''
' Starts playing the animation
'
' @param enhanced_img Enhanced image structure
'
SUB play_aseprite_animation (enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    enhanced_img.animation.is_playing = -1
    enhanced_img.animation.last_update = TIMER
END SUB

''
' Pauses the animation
'
' @param enhanced_img Enhanced image structure  
'
SUB pause_aseprite_animation (enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    enhanced_img.animation.is_playing = 0
END SUB

''
' Sets the current animation frame
'
' @param enhanced_img Enhanced image structure
' @param frame_index Frame index to display (0-based)
'
SUB set_aseprite_frame (enhanced_img AS ASEPRITE_ENHANCED_IMAGE, frame_index AS INTEGER)
    IF frame_index >= 0 AND frame_index < enhanced_img.animation.total_frames THEN
        enhanced_img.animation.current_frame = frame_index
        enhanced_img.animation.elapsed_time = 0
    END IF
END SUB

''
' Gets the number of layers in the image
'
' @param enhanced_img Enhanced image structure
' @return Number of layers
'
FUNCTION get_layer_count% (enhanced_img AS ASEPRITE_ENHANCED_IMAGE)
    get_layer_count% = enhanced_img.num_layers
END FUNCTION

''
' Gets the name of a specific layer
'
' @param enhanced_img Enhanced image structure
' @param layer_index Layer index (0-based)
' @return Layer name
'
FUNCTION get_layer_name$ (enhanced_img AS ASEPRITE_ENHANCED_IMAGE, layer_index AS INTEGER)
    DIM layer_names() AS STRING
    DIM name_count AS INTEGER
    
    ' Parse layer names from serialized string (simplified)
    IF LEN(enhanced_img.layer_info) > 0 THEN
        ' Split by CHR$(0) - simplified implementation
        IF layer_index < enhanced_img.num_layers THEN
            get_layer_name$ = "Layer " + STR$(layer_index + 1)
        ELSE
            get_layer_name$ = ""
        END IF
    ELSE
        get_layer_name$ = ""
    END IF
END FUNCTION

''
' Checks if a layer is visible
'
' @param enhanced_img Enhanced image structure
' @param layer_index Layer index (0-based)  
' @return -1 if visible, 0 if hidden
'
FUNCTION is_layer_visible% (enhanced_img AS ASEPRITE_ENHANCED_IMAGE, layer_index AS INTEGER)
    ' Simplified implementation - assume all layers visible for now
    IF layer_index >= 0 AND layer_index < enhanced_img.num_layers THEN
        is_layer_visible% = -1
    ELSE
        is_layer_visible% = 0
    END IF
END FUNCTION

''
' Sets layer visibility
'
' @param enhanced_img Enhanced image structure
' @param layer_index Layer index (0-based)
' @param visible -1 for visible, 0 for hidden
'
SUB set_layer_visibility (enhanced_img AS ASEPRITE_ENHANCED_IMAGE, layer_index AS INTEGER, visible AS INTEGER)
    ' TODO: Implement layer visibility control
    ' For now, this is a placeholder
END SUB

''
' Displays an enhanced Aseprite image with animation support
'
' @param enhanced_img Enhanced image structure
' @param scale Scale factor for display
' @param center_display 1 to center on screen, 0 for top-left
'
SUB display_aseprite_enhanced (enhanced_img AS ASEPRITE_ENHANCED_IMAGE, scale AS SINGLE, center_display AS INTEGER)
    DIM screen_width AS INTEGER, screen_height AS INTEGER
    DIM display_width AS INTEGER, display_height AS INTEGER
    DIM x_pos AS INTEGER, y_pos AS INTEGER
    DIM oldDest AS LONG
    
    IF enhanced_img.base_image.is_valid = 0 THEN
        ' Capture current destination for console output
        oldDest = _DEST
        IF _CONSOLE THEN
            _DEST _CONSOLE
            PRINT "Cannot display: Invalid enhanced Aseprite image"
            _DEST oldDest
        END IF
        EXIT SUB
    END IF
    
    ' Capture original destination before creating graphics
    oldDest = _DEST
    
    ' Create graphics screen if needed
    IF _PIXELSIZE(0) = 0 THEN
        SCREEN _NEWIMAGE(800, 600, 32)
        _TITLE "Enhanced Aseprite Viewer - " + enhanced_img.base_image.file_path
    END IF
    
    ' Calculate display dimensions
    display_width = INT(enhanced_img.base_image.header.width * scale)
    display_height = INT(enhanced_img.base_image.header.height * scale)
    
    screen_width = _WIDTH(0)
    screen_height = _HEIGHT(0)
    
    ' Calculate position
    IF center_display THEN
        x_pos = (screen_width - display_width) \ 2
        y_pos = (screen_height - display_height) \ 2
    ELSE
        x_pos = 10
        y_pos = 50
    END IF
    
    ' Clear screen
    CLS
    
    ' Display enhanced information
    COLOR _RGB32(255, 255, 255)
    _PRINTSTRING (10, 10), "Enhanced Aseprite: " + enhanced_img.base_image.file_path
    _PRINTSTRING (10, 30), "Layers: " + STR$(enhanced_img.num_layers) + " | Frames: " + STR$(enhanced_img.num_frames)
    
    ' Show animation status
    IF enhanced_img.animation.is_playing THEN
        _PRINTSTRING (10, 50), "Animation: Playing | Frame: " + STR$(enhanced_img.animation.current_frame + 1) + "/" + STR$(enhanced_img.animation.total_frames)
    ELSE
        _PRINTSTRING (10, 50), "Animation: Paused | Frame: " + STR$(enhanced_img.animation.current_frame + 1) + "/" + STR$(enhanced_img.animation.total_frames)
    END IF
    
    ' Update animation
    update_aseprite_animation enhanced_img
    
    ' For now, display the base image (TODO: render current frame with layers)
    DIM base_image_handle AS LONG
    base_image_handle = create_image_from_aseprite&(enhanced_img.base_image)
    
    IF base_image_handle <> 0 THEN
        IF scale = 1.0 THEN
            _PUTIMAGE (x_pos, y_pos), base_image_handle
        ELSE
            _PUTIMAGE (x_pos, y_pos)-(x_pos + display_width - 1, y_pos + display_height - 1), base_image_handle
        END IF
        _FREEIMAGE base_image_handle
    END IF
    
    ' Display controls
    _PRINTSTRING (10, screen_height - 60), "Controls: SPACE=Play/Pause, LEFT/RIGHT=Frame, ESC=Exit"
    _PRINTSTRING (10, screen_height - 40), "Enhanced display - Auto-closing in 3 seconds..."
    
    _DISPLAY
    
    ' Send status to console (check if console is available first)
    IF _CONSOLE THEN
        _DEST _CONSOLE
        PRINT "Enhanced Aseprite display shown - Graphics window active"
        PRINT "Layers: "; enhanced_img.num_layers; " | Frames: "; enhanced_img.num_frames
        IF enhanced_img.animation.is_playing THEN
            PRINT "Animation: Playing | Frame: "; enhanced_img.animation.current_frame + 1; "/"; enhanced_img.animation.total_frames
        ELSE
            PRINT "Animation: Paused | Frame: "; enhanced_img.animation.current_frame + 1; "/"; enhanced_img.animation.total_frames
        END IF
        PRINT "Auto-closing in 3 seconds..."
        _DEST oldDest
    END IF
    
    _DELAY 3
END SUB
